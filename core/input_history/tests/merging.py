from ..cursor_position_tracker import CursorPositionTracker, _CURSOR_MARKER
from ..input_history import InputHistoryManager
from ..input_history_typing import InputHistoryEvent

def get_empty_ihm() -> InputHistoryManager:
    return InputHistoryManager()

def get_filled_ihm() -> InputHistoryManager:
    input_history = get_empty_ihm()
    input_history.insert_input_events(input_history.text_to_input_history_events("This ", "This"))
    input_history.insert_input_events(input_history.text_to_input_history_events("is ", "is"))
    input_history.insert_input_events(input_history.text_to_input_history_events("a ", "a"))
    input_history.insert_input_events(input_history.text_to_input_history_events("test", "test"))
    input_history.insert_input_events(input_history.text_to_input_history_events(".or", "or"))    
    return input_history

print( "Detecting merge strategies for inserting input events in between events" )
previous_no_merge = get_filled_ihm().detect_merge_strategy(0, 0, InputHistoryEvent("Ask ", "ask", ""))
print( "    Should always append before the first event if the event cannot be merged", previous_no_merge == (0, -1, -1))
previous_no_merge_middle = get_filled_ihm().detect_merge_strategy(1, 0, InputHistoryEvent("ask ", "ask", ""))
print( "    Should always append before the second event if the event cannot be merged", previous_no_merge_middle == (0, -1, -1))
current_append_after = get_filled_ihm().detect_merge_strategy(0, 5, InputHistoryEvent("ask ", "ask", ""))
print( "    Should always append after the first event if the event cannot be merged", current_append_after == (-1, 0, -1))
current_middle_append_after = get_filled_ihm().detect_merge_strategy(1, 3, InputHistoryEvent("ask ", "ask", ""))
print( "    Should merge append after the second event if the event cannot be merged", current_middle_append_after == (-1, 0, -1))
current_first_merge = get_filled_ihm().detect_merge_strategy(0, 0, InputHistoryEvent("Ask", "ask", ""))
print( "    Should merge with the first event if the event can be merged at the start", current_first_merge == (-1, 1, -1))
second_first_merge = get_filled_ihm().detect_merge_strategy(1, 0, InputHistoryEvent("Ask", "ask", ""))
print( "    Should merge with the second event if the event can be merged at the start", second_first_merge == (-1, 1, -1))
fourth_first_merge = get_filled_ihm().detect_merge_strategy(3, 0, InputHistoryEvent("Ask", "ask", ""))
print( "    Should merge with the current event if the event can be merged at the start", fourth_first_merge == (-1, 1, -1))
third_last_merge = get_filled_ihm().detect_merge_strategy(2, 2, InputHistoryEvent("Ask", "ask", ""))
print( "    Should merge with the final event if the event can be merged at the end of the current event", third_last_merge == (-1, -1, 1))
fourth_last_merge = get_filled_ihm().detect_merge_strategy(3, 5, InputHistoryEvent("Ask", "ask", ""))
print( "    Should merge with the current event if the event can be merged at the end", fourth_last_merge == (-1, 1, -1))
final_last_merge = get_filled_ihm().detect_merge_strategy(4, 3, InputHistoryEvent("Ask", "ask", ""))
print( "    Should merge with the final event if the event can be merged at the end", final_last_merge == (-1, 1, -1))

print( "Detecting merge strategies for inserting input events in the middle of events" )
first_merge_middle = get_filled_ihm().detect_merge_strategy(0, 1, InputHistoryEvent("ask", "ask", ""))
print( "    Should merge with the first event if the event can be merged from both sides", first_merge_middle == (-1, 1, -1))
current_merge_middle = get_filled_ihm().detect_merge_strategy(1, 1, InputHistoryEvent("ask", "ask", ""))
print( "    Should merge with the current event if the event can be merged from both sides", current_merge_middle == (-1, 1, -1))
final_merge_middle = get_filled_ihm().detect_merge_strategy(4, 1, InputHistoryEvent("ask", "ask", ""))
print( "    Should merge with the final event if the event can be merged from both sides", current_merge_middle == (-1, 1, -1))
first_split_left = get_filled_ihm().detect_merge_strategy(0, 1, InputHistoryEvent(" ask", "ask", ""))
print( "    Should split left of the first event if the event can only be merged from the right", first_split_left == (-1, 2, -1))
current_split_left = get_filled_ihm().detect_merge_strategy(1, 1, InputHistoryEvent(" ask", "ask", ""))
print( "    Should split left of the current event if the event can only be merged from the right", current_split_left == (-1, 2, -1))
final_split_left = get_filled_ihm().detect_merge_strategy(4, 1, InputHistoryEvent(" ask", "ask", ""))
print( "    Should split left of the final event if the event can only be merged from the right", final_split_left == (-1, 2, -1))
first_split_right = get_filled_ihm().detect_merge_strategy(0, 1, InputHistoryEvent("ask ", "ask", ""))
print( "    Should split right of the first event if the event can only be merged from the left", first_split_right == (-1, 3, -1))
current_split_right = get_filled_ihm().detect_merge_strategy(1, 1, InputHistoryEvent("ask ", "ask", ""))
print( "    Should split right of the current event if the event can only be merged from the left", current_split_right == (-1, 3, -1))
final_split_right = get_filled_ihm().detect_merge_strategy(4, 1, InputHistoryEvent("ask ", "ask", ""))
print( "    Should split right of the final event if the event can only be merged from the left", final_split_right == (-1, 3, -1))
first_split_both = get_filled_ihm().detect_merge_strategy(0, 1, InputHistoryEvent(" ask ", "ask", ""))
print( "    Should split on both sides of the first event if the event cannot be merged", first_split_both == (-1, 4, -1))
current_split_both = get_filled_ihm().detect_merge_strategy(1, 1, InputHistoryEvent(" ask ", "ask", ""))
print( "    Should split on both sides of the current event if the event cannot be merged", current_split_both == (-1, 4, -1))
final_split_both = get_filled_ihm().detect_merge_strategy(4, 1, InputHistoryEvent(" ask ", "ask", ""))
print( "    Should split on both sides of the final event if the event cannot be merged", final_split_both == (-1, 4, -1))


#input_history = InputHistoryManager()
#input_history.insert_input_events(input_history.text_to_input_history_events("Insert a new sentence. \n", "insert a new sentence"))
#input_history.insert_input_events(input_history.text_to_input_history_events("Insert a second sentence. \n", "insert a second sentence"))
#input_history.insert_input_events(input_history.text_to_input_history_events("Insert a third sentence.", "insert a third sentence"))
#input_history.cursor_position_tracker.text_history = """Insert a new sentence. 
#Insert a second """ + _CURSOR_MARKER + """sentence. 
#Insert a third sentence."""

#print( "Inserting in between input events") 
#print( "    Inserting text into a filled input history...")    
#input_history.insert_input_events(input_history.text_to_input_history_events("important ", "important"))
#print( "        Expect history length to stay the same (3)", len(input_history.input_history) == 3)
#cursor_index = input_history.cursor_position_tracker.get_cursor_index()
#print( "        Expect cursor line index to be 1", cursor_index[0] == 1)
#print( "        Expect cursor character index to be the same as before (10)", cursor_index[1] == 10)
#input_index = input_history.determine_input_index()
#print( "        Expect input index to be 1", input_index[0] == 1)
#print( "        Expect input character index to be the length of the merged sentence minus the word sentence (26)", input_index[input_index[0]] == 26 )
#print( "        Expect the phrase to be merged", input_history.input_history[input_index[0]].phrase == "insert a second important sentence" )
#print( "        Expect the text to be merged", input_history.input_history[input_index[0]].text == "Insert a second important sentence. \n" )
#print( "    Inserting a new line into the filled input history...") 
#input_history.insert_input_events(input_history.text_to_input_history_events("\n", ""))
#print( "        Expect history length to increase by one (4)", len(input_history.input_history) == 4) 
##print( "        Expect split line to have an increased line index", input_history.input_history[2].line_index == 2)
#print( "        Expect line after that to have increased its index as well", input_history.input_history[3].line_index == 3)
#print( "        Expect the character index of the merged item to reset to 0", input_history.input_history[1].index_from_line_end == 0)
##print( "        Expect the character index of the next to be the same", input_history.input_history[2].index_from_line_end == 0)
#print( "    Inserting a word after the new line in the filled input history...")
#input_history.insert_input_events(input_history.text_to_input_history_events("Big ", "big")) 
#print( "        Expect history length to increase by one (5)", len(input_history.input_history) == 5)
#print( "        Expect line indexes to be the same", input_history.input_history[2].line_index == 2)
#print( "        Expect the appended event to have a larger character index because it was added before words", input_history.input_history[2].index_from_line_end == 10)
#print( "        Expect follow up events on the same line to have the same character index", input_history.input_history[3].index_from_line_end == 0)
#print( "    Inserting another word after the new word in the filled input history...")
#input_history.insert_input_events(input_history.text_to_input_history_events("red ", "red"))
#print( "        Expect history length to increase by one (6)", len(input_history.input_history) == 6)
#print( "        Expect line indexes to be the same", input_history.input_history[3].line_index == 2)
#print( "        Expect the appended event to have a larger character index because it was added before words", input_history.input_history[3].index_from_line_end == 10)
#print( "        Expect the previous event to have a larger character index", input_history.input_history[2].index_from_line_end == 14)
#print( "        Expect follow up events on the same line to have the same character index", input_history.input_history[4].index_from_line_end == 0)
             